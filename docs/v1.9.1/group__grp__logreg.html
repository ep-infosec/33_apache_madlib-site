<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<meta name="keywords" content="madlib,postgres,greenplum,machine learning,data mining,deep learning,ensemble methods,data science,market basket analysis,affinity analysis,pca,lda,regression,elastic net,huber white,proportional hazards,k-means,latent dirichlet allocation,bayes,support vector machines,svm"/>
<title>MADlib: Logistic Regression</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<!-- hack in the navigation tree -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="madlib_extra.css" rel="stylesheet" type="text/css"/>
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45382226-1', 'madlib.net');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://madlib.net"><img alt="Logo" src="madlib.png" height="50" style="padding-left:0.5em;" border="0"/ ></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   <span id="projectnumber">1.9.1</span>
   </div>
   <div id="projectbrief">User Documentation for MADlib</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__grp__logreg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Logistic Regression<div class="ingroups"><a class="el" href="group__grp__super.html">Supervised Learning</a> &raquo; <a class="el" href="group__grp__regml.html">Regression Models</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><b>Contents</b></p><ul>
<li class="level1">
<a href="#train">Training Function</a> </li>
<li class="level1">
<a href="#predict">Prediction Function</a> </li>
<li class="level1">
<a href="#examples">Examples</a> </li>
<li class="level1">
<a href="#background">Technical Background</a> </li>
<li class="level1">
<a href="#literature">Literature</a> </li>
<li class="level1">
<a href="#related">Related Topics</a> </li>
</ul>
</div><p>Binomial logistic regression models the relationship between a dichotomous dependent variable and one or more predictor variables. The dependent variable may be a Boolean value or a categorial variable that can be represented with a Boolean expression. The probabilities describing the possible outcomes of a single trial are modeled, as a function of the predictor variables, using a logistic function.</p>
<p><a class="anchor" id="train"></a></p><dl class="section user"><dt>Training Function</dt><dd>The logistic regression training function has the following format: <pre class="syntax">
logregr_train( source_table,
               out_table,
               dependent_varname,
               independent_varname,
               grouping_cols,
               max_iter,
               optimizer,
               tolerance,
               verbose
             )
</pre> <b>Arguments</b> <dl class="arglist">
<dt>source_table </dt>
<dd><p class="startdd">TEXT. The name of the table containing the training data.</p>
<p class="enddd"></p>
</dd>
<dt>out_table </dt>
<dd><p class="startdd">TEXT. Name of the generated table containing the output model.</p>
<p>The output table produced by the logistic regression training function contains the following columns:</p>
<table  class="output">
<tr>
<th>&lt;...&gt; </th><td><p class="starttd">Text. Grouping columns, if provided in input. This could be multiple columns depending on the <code>grouping_col</code> input. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>coef </th><td><p class="starttd">FLOAT8. Vector of the coefficients of the regression. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>log_likelihood </th><td><p class="starttd">FLOAT8. The log-likelihood <img class="formulaInl" alt="$ l(\boldsymbol c) $" src="form_79.png"/>. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>std_err </th><td><p class="starttd">FLOAT8[]. Vector of the standard error of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>z_stats </th><td><p class="starttd">FLOAT8[]. Vector of the z-statistics of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>p_values </th><td><p class="starttd">FLOAT8[]. Vector of the p-values of the coefficients. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>odds_ratios </th><td><p class="starttd">FLOAT8[]. The odds ratio, <img class="formulaInl" alt="$ \exp(c_i) $" src="form_115.png"/>. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>condition_no </th><td><p class="starttd">FLOAT8[]. The condition number of the <img class="formulaInl" alt="$X^{*}X$" src="form_325.png"/> matrix. A high condition number is usually an indication that there may be some numeric instability in the result yielding a less reliable model. A high condition number often results when there is a significant amount of colinearity in the underlying design matrix, in which case other regression techniques may be more appropriate. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_iterations </th><td>INTEGER. The number of iterations actually completed. This would be different from the <code>nIterations</code> argument if a <code>tolerance</code> parameter is provided and the algorithm converges before all iterations are completed.  </td></tr>
<tr>
<th>num_rows_processed </th><td>INTEGER. The number of rows actually processed, which is equal to the total number of rows in the source table minus the number of skipped rows.  </td></tr>
<tr>
<th>num_missing_rows_skipped </th><td>INTEGER. The number of rows skipped during the training. A row will be skipped if the independent_varname is NULL or contains NULL values.  </td></tr>
</table>
<p>A summary table named &lt;out_table&gt;_summary is also created at the same time, which has the following columns: </p><table  class="output">
<tr>
<th>source_table </th><td><p class="starttd">The data source table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>out_table </th><td><p class="starttd">The output table name. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>dependent_varname </th><td><p class="starttd">The dependent variable. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>independent_varname </th><td><p class="starttd">The independent variables </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>optimizer_params </th><td><p class="starttd">A string that contains all the optimizer parameters, and has the form of 'optimizer=..., max_iter=..., tolerance=...' </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_all_groups </th><td><p class="starttd">How many groups of data were fit by the logistic model. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_failed_groups </th><td><p class="starttd">How many groups' fitting processes failed. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_rows_processed </th><td><p class="starttd">The total number of rows usd in the computation. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>num_missing_rows_skipped </th><td>The total number of rows skipped.  </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>dependent_varname </dt>
<dd><p class="startdd">TEXT. Name of the dependent variable column (of type BOOLEAN) in the training data or an expression evaluating to a BOOLEAN.</p>
<p class="enddd"></p>
</dd>
<dt>independent_varname </dt>
<dd><p class="startdd">TEXT. Expression list to evaluate for the independent variables. An intercept variable is not assumed. It is common to provide an explicit intercept term by including a single constant <code>1</code> term in the independent variable list.</p>
<p class="enddd"></p>
</dd>
<dt>grouping_cols (optional) </dt>
<dd><p class="startdd">TEXT, default: NULL. An expression list used to group the input dataset into discrete groups, running one regression per group. Similar to the SQL "GROUP BY" clause. When this value is NULL, no grouping is used and a single result model is generated.</p>
<p class="enddd"></p>
</dd>
<dt>max_iter (optional) </dt>
<dd><p class="startdd">INTEGER, default: 20. The maximum number of iterations that are allowed.</p>
<p class="enddd"></p>
</dd>
<dt>optimizer (optional) </dt>
<dd><p class="startdd">TEXT, default: 'irls'. The name of the optimizer to use: </p><table  class="output">
<tr>
<th>'newton' or 'irls' </th><td>Iteratively reweighted least squares  </td></tr>
<tr>
<th>'cg' </th><td>conjugate gradient  </td></tr>
<tr>
<th>'igd' </th><td>incremental gradient descent.  </td></tr>
</table>
<p class="enddd"></p>
</dd>
<dt>tolerance (optional) </dt>
<dd><p class="startdd">FLOAT8, default: 0.0001. The difference between log-likelihood values in successive iterations that should indicate convergence. A zero disables the convergence criterion, so that execution stops after <code>n</code> iterations have completed.</p>
<p class="enddd"></p>
</dd>
<dt>verbose (optional) </dt>
<dd>BOOLEAN, default: FALSE. Provides verbose output of the results of training. </dd>
</dl>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For p-values, we just return the computation result directly. Other statistical packages, like 'R', produce the same result, but on printing the result to screen, another format function is used and any p-value that is smaller than the machine epsilon (the smallest positive floating-point number 'x' such that '1 + x != 1') will be printed on screen as "&lt; xxx" (xxx is the value of the machine epsilon). Although the result may look different, they are in fact the same.</dd></dl>
<p><a class="anchor" id="predict"></a></p><dl class="section user"><dt>Prediction Function</dt><dd>Two prediction functions are provided to either predict the boolean value of the dependent variable or the probability of the value of dependent variable being 'True', both functions using the same syntax.</dd></dl>
<p>The function to predict the boolean value (True/False) of the dependent variable has the following syntax: </p><pre class="syntax">
logregr_predict(coefficients,
                ind_var
               )
</pre><p>The function to predict the probability of the dependent variable being True has the following syntax: </p><pre class="syntax">
logregr_predict_prob(coefficients,
                     ind_var
                    )
</pre><p><b>Arguments</b> </p><dl class="arglist">
<dt>coefficients </dt>
<dd><p class="startdd">DOUBLE PRECISION[]. Model coefficients obtained from <a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428">logregr_train()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>ind_var </dt>
<dd>Independent variables, as a DOUBLE array. This should be the same length as the array obtained by evaluation of the 'independent_varname' argument in <a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428">logregr_train()</a>. </dd>
</dl>
<p><a class="anchor" id="examples"></a></p><dl class="section user"><dt>Examples</dt><dd><ol type="1">
<li>Create the training data table. <pre class="example">
CREATE TABLE patients( id INTEGER NOT NULL,
                       second_attack INTEGER,
                       treatment INTEGER,
                       trait_anxiety INTEGER);
COPY patients FROM STDIN WITH DELIMITER '|';
  1 |             1 |         1 |            70
  3 |             1 |         1 |            50
  5 |             1 |         0 |            40
  7 |             1 |         0 |            75
  9 |             1 |         0 |            70
 11 |             0 |         1 |            65
 13 |             0 |         1 |            45
 15 |             0 |         1 |            40
 17 |             0 |         0 |            55
 19 |             0 |         0 |            50
  2 |             1 |         1 |            80
  4 |             1 |         0 |            60
  6 |             1 |         0 |            65
  8 |             1 |         0 |            80
 10 |             1 |         0 |            60
 12 |             0 |         1 |            50
 14 |             0 |         1 |            35
 16 |             0 |         1 |            50
 18 |             0 |         0 |            45
 20 |             0 |         0 |            60
\.
</pre></li>
<li>Train a regression model. <pre class="example">
SELECT madlib.logregr_train( 'patients',
                             'patients_logregr',
                             'second_attack',
                             'ARRAY[1, treatment, trait_anxiety]',
                             NULL,
                             20,
                             'irls'
                           );
</pre> (Note that in this example we are dynamically creating the array of independent variables from column names. If you have large numbers of independent variables beyond the PostgreSQL limit of maximum columns per table, you would pre-build the arrays and store them in a single column.)</li>
<li>View the regression results. <pre class="example">
-- Set extended display on for easier reading of output
\x on
SELECT * from patients_logregr;
</pre> Result: <pre class="result">
coef           | {5.59049410898112,2.11077546770772,-0.237276684606453}
log_likelihood | -467.214718489873
std_err        | {0.318943457652178,0.101518723785383,0.294509929481773}
z_stats        | {17.5281667482197,20.7919819024719,-0.805666162169712}
p_values       | {8.73403463417837e-69,5.11539430631541e-96,0.420435365338518}
odds_ratios    | {267.867942976278,8.2546400100702,0.788773016471171}
condition_no   | 179.186118573205
num_iterations | 9
</pre></li>
<li>Alternatively, unnest the arrays in the results for easier reading of output: <pre class="example">
\x off
SELECT unnest(array['intercept', 'treatment', 'trait_anxiety']) as attribute,
       unnest(coef) as coefficient,
       unnest(std_err) as standard_error,
       unnest(z_stats) as z_stat,
       unnest(p_values) as pvalue,
       unnest(odds_ratios) as odds_ratio
    FROM patients_logregr;
</pre></li>
<li>Predicting dependent variable using the logistic regression model. (This example uses the original data table to perform the prediction. Typically a different test dataset with the same features as the original training dataset would be used for prediction.) <pre class="example">
\x off
-- Display prediction value along with the original value
SELECT p.id, madlib.logregr_predict(coef, ARRAY[1, treatment, trait_anxiety]),
       p.second_attack
FROM patients p, patients_logregr m
ORDER BY p.id;
</pre></li>
<li>Predicting the probability of the dependent variable being TRUE. <pre class="example">
\x off
-- Display prediction value along with the original value
SELECT p.id, madlib.logregr_predict_prob(coef, ARRAY[1, treatment, trait_anxiety])
FROM patients p, patients_logregr m
ORDER BY p.id;
</pre></li>
</ol>
</dd></dl>
<p><a class="anchor" id="notes"></a></p><dl class="section user"><dt>Notes</dt><dd>All table names can be optionally schema qualified (current_schemas() would be searched if a schema name is not provided) and all table and column names should follow case-sensitivity and quoting rules per the database. (For instance, 'mytable' and 'MyTable' both resolve to the same entity, i.e. 'mytable'. If mixed-case or multi-byte characters are desired for entity names then the string should be double-quoted; in this case the input would be '"MyTable"').</dd></dl>
<p><a class="anchor" id="background"></a></p><dl class="section user"><dt>Technical Background</dt><dd></dd></dl>
<p>(Binomial) logistic regression refers to a stochastic model in which the conditional mean of the dependent dichotomous variable (usually denoted <img class="formulaInl" alt="$ Y \in \{ 0,1 \} $" src="form_354.png"/>) is the logistic function of an affine function of the vector of independent variables (usually denoted <img class="formulaInl" alt="$ \boldsymbol x $" src="form_58.png"/>). That is, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E[Y \mid \boldsymbol x] = \sigma(\boldsymbol c^T \boldsymbol x) \]" src="form_94.png"/>
</p>
<p> for some unknown vector of coefficients <img class="formulaInl" alt="$ \boldsymbol c $" src="form_78.png"/> and where <img class="formulaInl" alt="$ \sigma(x) = \frac{1}{1 + \exp(-x)} $" src="form_95.png"/> is the logistic function. Logistic regression finds the vector of coefficients <img class="formulaInl" alt="$ \boldsymbol c $" src="form_78.png"/> that maximizes the likelihood of the observations.</p>
<p>Let</p><ul>
<li><img class="formulaInl" alt="$ \boldsymbol y \in \{ 0,1 \}^n $" src="form_355.png"/> denote the vector of observed dependent variables, with <img class="formulaInl" alt="$ n $" src="form_10.png"/> rows, containing the observed values of the dependent variable,</li>
<li><img class="formulaInl" alt="$ X \in \mathbf R^{n \times k} $" src="form_98.png"/> denote the design matrix with <img class="formulaInl" alt="$ k $" src="form_97.png"/> columns and <img class="formulaInl" alt="$ n $" src="form_10.png"/> rows, containing all observed vectors of independent variables <img class="formulaInl" alt="$ \boldsymbol x_i $" src="form_99.png"/> as rows.</li>
</ul>
<p>By definition, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P[Y = y_i | \boldsymbol x_i] = \sigma((-1)^{(1 - y_i)} \cdot \boldsymbol c^T \boldsymbol x_i) \,. \]" src="form_356.png"/>
</p>
<p> Maximizing the likelihood <img class="formulaInl" alt="$ \prod_{i=1}^n \Pr(Y = y_i \mid \boldsymbol x_i) $" src="form_101.png"/> is equivalent to maximizing the log-likelihood <img class="formulaInl" alt="$ \sum_{i=1}^n \log \Pr(Y = y_i \mid \boldsymbol x_i) $" src="form_102.png"/>, which simplifies to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ l(\boldsymbol c) = -\sum_{i=1}^n \log(1 + \exp((-1)^{(1 - y_i)} \cdot \boldsymbol c^T \boldsymbol x_i)) \,. \]" src="form_357.png"/>
</p>
<p> The Hessian of this objective is <img class="formulaInl" alt="$ H = -X^T A X $" src="form_104.png"/> where <img class="formulaInl" alt="$ A = \text{diag}(a_1, \dots, a_n) $" src="form_105.png"/> is the diagonal matrix with <img class="formulaInl" alt="$ a_i = \sigma(\boldsymbol c^T \boldsymbol x) \cdot \sigma(-\boldsymbol c^T \boldsymbol x) \,. $" src="form_106.png"/> Since <img class="formulaInl" alt="$ H $" src="form_107.png"/> is non-positive definite, <img class="formulaInl" alt="$ l(\boldsymbol c) $" src="form_79.png"/> is convex. There are many techniques for solving convex optimization problems. Currently, logistic regression in MADlib can use one of three algorithms:</p><ul>
<li>Iteratively Reweighted Least Squares</li>
<li>A conjugate-gradient approach, also known as Fletcher-Reeves method in the literature, where we use the Hestenes-Stiefel rule for calculating the step size.</li>
<li>Incremental gradient descent, also known as incremental gradient methods or stochastic gradient descent in the literature.</li>
</ul>
<p>We estimate the standard error for coefficient <img class="formulaInl" alt="$ i $" src="form_32.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathit{se}(c_i) = \left( (X^T A X)^{-1} \right)_{ii} \,. \]" src="form_108.png"/>
</p>
<p> The Wald z-statistic is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_i = \frac{c_i}{\mathit{se}(c_i)} \,. \]" src="form_109.png"/>
</p>
<p>The Wald <img class="formulaInl" alt="$ p $" src="form_110.png"/>-value for coefficient <img class="formulaInl" alt="$ i $" src="form_32.png"/> gives the probability (under the assumptions inherent in the Wald test) of seeing a value at least as extreme as the one observed, provided that the null hypothesis ( <img class="formulaInl" alt="$ c_i = 0 $" src="form_111.png"/>) is true. Letting <img class="formulaInl" alt="$ F $" src="form_112.png"/> denote the cumulative density function of a standard normal distribution, the Wald <img class="formulaInl" alt="$ p $" src="form_110.png"/>-value for coefficient <img class="formulaInl" alt="$ i $" src="form_32.png"/> is therefore </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_i = \Pr(|Z| \geq |z_i|) = 2 \cdot (1 - F( |z_i| )) \]" src="form_113.png"/>
</p>
<p> where <img class="formulaInl" alt="$ Z $" src="form_114.png"/> is a standard normally distributed random variable.</p>
<p>The odds ratio for coefficient <img class="formulaInl" alt="$ i $" src="form_32.png"/> is estimated as <img class="formulaInl" alt="$ \exp(c_i) $" src="form_115.png"/>.</p>
<p>The condition number is computed as <img class="formulaInl" alt="$ \kappa(X^T A X) $" src="form_116.png"/> during the iteration immediately <em>preceding</em> convergence (i.e., <img class="formulaInl" alt="$ A $" src="form_13.png"/> is computed using the coefficients of the previous iteration). A large condition number (say, more than 1000) indicates the presence of significant multicollinearity.</p>
<p><a class="anchor" id="literature"></a></p><dl class="section user"><dt>Literature</dt><dd></dd></dl>
<p>A somewhat random selection of nice write-ups, with valuable pointers into further literature.</p>
<p>[1] Cosma Shalizi: Statistics 36-350: Data Mining, Lecture Notes, 18 November 2009, <a href="http://www.stat.cmu.edu/~cshalizi/350/lectures/26/lecture-26.pdf">http://www.stat.cmu.edu/~cshalizi/350/lectures/26/lecture-26.pdf</a></p>
<p>[2] Thomas P. Minka: A comparison of numerical optimizers for logistic regression, 2003 (revised Mar 26, 2007), <a href="http://research.microsoft.com/en-us/um/people/minka/papers/logreg/minka-logreg.pdf">http://research.microsoft.com/en-us/um/people/minka/papers/logreg/minka-logreg.pdf</a></p>
<p>[3] Paul Komarek, Andrew W. Moore: Making Logistic Regression A Core Data Mining Tool With TR-IRLS, IEEE International Conference on Data Mining 2005, pp. 685-688, <a href="http://komarix.org/ac/papers/tr-irls.short.pdf">http://komarix.org/ac/papers/tr-irls.short.pdf</a></p>
<p>[4] D. P. Bertsekas: Incremental gradient, subgradient, and proximal methods for convex optimization: a survey, Technical report, Laboratory for Information and Decision Systems, 2010, <a href="http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf">http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf</a></p>
<p>[5] A. Nemirovski, A. Juditsky, G. Lan, and A. Shapiro: Robust stochastic approximation approach to stochastic programming, SIAM Journal on Optimization, 19(4), 2009, <a href="http://www2.isye.gatech.edu/~nemirovs/SIOPT_RSA_2009.pdf">http://www2.isye.gatech.edu/~nemirovs/SIOPT_RSA_2009.pdf</a></p>
<p><a class="anchor" id="related"></a></p><dl class="section user"><dt>Related Topics</dt><dd></dd></dl>
<p>File <a class="el" href="logistic_8sql__in.html" title="SQL functions for logistic regression. ">logistic.sql_in</a> documenting the training function</p>
<p><a class="el" href="logistic_8sql__in.html#a74210a7ef513dfcbdfdd9f3b37bfe428" title="Compute logistic-regression coefficients and diagnostic statistics. ">logregr_train()</a></p>
<p><a class="el" href="elastic__net_8sql__in.html#a735038a5090c112505c740a90a203e83" title="Interface for elastic net. ">elastic_net_train()</a></p>
<p><a class="el" href="group__grp__linreg.html">Linear Regression</a></p>
<p><a class="el" href="group__grp__multinom.html">Multinomial Regression</a></p>
<p><a class="el" href="group__grp__ordinal.html">Ordinal Regression</a></p>
<p><a class="el" href="group__grp__robust.html">Robust Variance</a></p>
<p><a class="el" href="group__grp__clustered__errors.html">Clustered Variance</a></p>
<p><a class="el" href="group__grp__validation.html">Cross Validation</a></p>
<p><a class="el" href="group__grp__marginal.html">Marginal Effects</a></p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Sep 20 2016 11:27:01 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
